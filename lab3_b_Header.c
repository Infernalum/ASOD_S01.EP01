#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
#include "Lab3_b_Header.h"
#include <malloc.h>
#include <math.h>

// Формирование списка из строки любой длины, вводимой из входного потока
int getList(Item** pptr) {
	char buf[81] /* Массив для переноса строки из входного потока в список */, *str /* Указатель на строку */;
	Item head = { '*', NULL };                          // Локальная переменная                      
	int n /* Возвращаемое значение scanf() */, rc = 1 /* Результат работы функции */;
	do {
		n = scanf("%80[^\n]", buf);                     // Размер памяти - 80 ( в buf + 1, для "/0"); вводит в buf все символы, кроме "\n" ("\n" остается во входном потоке)
		if (n < 0) {                                    // Конец файла или ошибка ввода => освободить память от списка, вернуть нулевой указатель на список
			deleteList(head.next);
			head.next = NULL;
			rc = 0;
			continue;                                   // continue для того, чтобы вернуть нулевой указатель в основную функцию
		}
		if (n > 0) {								    // Строка не пустая, => сформировать список
			for (str = buf; *str != '\0'; ++str)
				shift(&head, str);
		}
		else
			scanf("%*c");					        	// Введена пустая строка => во входном потоке только "\n" => подавить присвоение '\n' из входного потока                          
	} while (n > 0);
	*pptr = head.next;                                  // Возвращает указатель на первый элемент списка
	return rc;
}

// Проверка строки на корректность ввода
int checkList(Item* ptr) {
	for (; ptr != NULL; ptr = ptr->next)
		if ((ptr->c != ' ') && (ptr->c != '\t') && (ptr->c != '0') && (ptr->c != '1'))
			return 0;
	return 1;
}


// Нахождение указателя на самый последний узел в списке
Item* getLast(Item* last) {
	if (last == NULL)                           // Если список пуст, то вернуть нулевой указатель
		return NULL;
	while (last->next)                          // Пока указатель на след узел не NULL, передвивать указатель
		last = last->next;
	return last;                                // Возвращение указателя на последний узел списка
}



// Добавление узла в конец списка
void shift(Item* head, char* str) {
	Item* tmp = (Item*)malloc(sizeof(Item));    // Выделение места для нового узла 
	Item* last = getLast(head);                 // Перестановка last на последний узел списка
	tmp->c = *str;                              // Добавление в новый узед значения
	tmp->next = NULL;                           // Указатель нового узла NULL
	last->next = tmp;                           // Связывание последнего узла списка с новым элементом
}

// Удаление начального узла ОС (т.к. указатель head изменяется, необходимо передавать указатель на указатель) (Список быть пустым не может, поэтому обрабатывать не надо)
void pop(Item** head) {
	Item* tmp = NULL;
	tmp = (*head);              // Указатель указывает (ваще не тавтология) на голову ОС
	(*head) = (*head)->next;    // Переставляем указатель на голову ОС вперед
	free(tmp);                  // Очищаем узел tmp
}

// Удаление последнего узла ОС (список пустым быть не может, т.к. там в любом случае есть *, => обрабатывать не надо)
void popBack(Item** head) {
	Item *pF = *head /* последний узел */, *pB = NULL /* предыдущий узел */;
	while (pF->next) {      // Пока не последний узел, запоминаем его в pF и сдвигаем
		pB = pF;
		pF = pF->next;
	}
	if (pB == NULL) {       // Если был всего один элемент в списке, то удалить его
		free(*head);
		*head = NULL;
	}
	else {                 
		free(pF->next);    // Иначе освободить последний узел
		pB->next = NULL;   // Перевести указатель теперь последнего узла на NULL (т.е. сделать его последним)
	}
}

// Пропуск лидирующих пробелов и знаков табуляции
Item* skipSpace(Item* ptr) {
	while ((ptr->c == ' ') || (ptr->c == '\t')) {
		ptr = ptr->next;
	}
	return ptr;
}

// Печать списка
void putList(char* msg, Item* ptr) {           // msg - massage
	printf("%s: \"", msg);                 // '\"' - чаровский символ двойных ковычек
	for (; ptr != NULL; ptr = ptr->next)   // Пока указатель на след узел не NULL, выводим данные текущего корня 
		printf("%c", ptr->c);
	printf("\"\n");
}

// Удаление списка
void deleteList(Item* head) {
	Item *tmp = NULL;                      // Указатель на последующий узел
	while (head != NULL)                   // Пока список не пуст, удаляем эл-ты, начиная с начала
		pop(&head);
}


// Кривой перевод из двоичной СЧ в шестнадцатиричную
//                                                            WARNING!
//                                          Работает только в системах с кодировкой ASCII 
Item* construct(Item* p) {
	int nmb = 0 /* Само число в десятичной СЧ */, lng = 0 /* Длина слова (кол-во цифр) */;
	for (Item* tmp = p; tmp->c != ' ' && tmp->c != '\t' && tmp->c != '*'; tmp = tmp->next)   // Считаем кол-во цмфр в числе (нужно для того, чтобы перевеси число в десятичную СЧ)
		lng++;
	Item* tmp = p;																			 // "Бегающий" укащатель в ОС
	while (tmp->c != ' ' && tmp->c != '\t' && tmp->c != '*') {								 // Перевод из двоичной СЧ в десятичную
		--lng;
		nmb += (int)(tmp->c - '0') * (int)pow(2, lng);										 // Явное преобразование char (символьного типа) к int (код '0' - 48; каждой след. цифры на 1 больше предыдущей)
		tmp = tmp->next;
	}
	int deg = 0 /* максимальный разряд числа в шестнадцатиричной СЧ */;
	for (int i = nmb / 16; i > 0; i /= 16)
		++deg;
	do {												// Перевод из десятичной СЧ в шестнадцатиричную
		int now = nmb / (int)pow(16, deg) + '0';        // Текущая цифра в шестнадцатиричной запсии
		if (now == 48)									// Если остался последний разряд, то должен быть последний заход в цикл                                  
			nmb = 0;
		else
			nmb %= (now - '0') * (int)pow(16, deg);     // Либо вычисляем новое nmb с учетом переведенной цифры
		--deg;
		if (now > 57)                                   // Для цифр от '0' до '9' ASCII-коды 48-57, для букв от 'a' до 'f' 97-102
			now += 39;
		shift(p, &now);				                    // Добавление новой цифры в конец ОС
	} while (nmb);
	shift(p, " ");                                      // Добавление пробела в конец ОС
	p = tmp;                                            // Перенос указателя на узел на след эл-т после текущего числа
	return p;
}

// Преобразование исходного списка
Item *reorg(Item* p) {
	Item head = { '\0', p };                 // head это ЛОКАЛЬНАЯ ПЕРЕМЕННАЯ
	shift(&head, "*");                       // Добавляем в конец знак-сигнал (признак окончания строки)
	Item *last = head.next;                  // Указатель, "бегущий" до конца строки (до знака-сигнала)
	while (last->c != '*') {                 // Пока не конец строки
		last = skipSpace(last);              // Пропустить лидирующие пробелы и/или знаки табуляции
		if (last->c != '*')                  // Если в конце строки были пробелы, то после skipSpace brd будет указывать на знак-сигнал
			last = construct(last);          // Преобразовать текучее число и добавить его в конец 
	}                                        
	if (getLast(head.next)->c == '*') {      // Если в строке не было чисел (т.е. только пробелы/табуляция/ничего) => while не выполнялся
		while (head.next->c != '*')          // Удаляем все пробелы/табуляции исходной строки
			pop(&head.next);
		popBack(&head.next);                 // Удаляем знак-сигнал
	}
	else {
		popBack(&head.next);                 // Удалить последний пробел (или, в случае пустой строки знак-сигнал)
		while (head.next->c != '*')          // Удаляем все символы исходной строки
			pop(&head.next);
		pop(&head.next);                     // Удаляем знак-сигнал
	}
	return head.next;
}

