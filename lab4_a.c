/********************************************************************************************************************************************************************************************************/
/* Лаба 4(а).
  Вариант 40***.
	Написать программу для работы таблицей, использующей два пространства ключей, по запросам оператора.
	Каждый элемент таблицы имеет следующую структуру:
  struct Item {
	int key1;      // Ключ элемента из 1-ого пространства ключей
	int key2;       // Ключ элемента из 2-ого пространства ключей
	char *info;    // Указатель на информацию
	int ind1;	   // Связь с элементом 1-ого пространства ключей
	int ind2;	   // Связь с элементом 2-ого пространства ключей
  };
  Каждое пространство ключей организовано по принципу перемешанной таблицы, использующей перемешивание сложением. Максимальный размер таблицы ограничен
(для создания максимального размера таблицы использовать константу - например, const int SIZE = ...; ).
  Предусмотреть следующие операции:
	- Включение нового элемента в таблицу при условии, что в таблице не может быть двух элементов с одинаковыми ключами;
	- Удаление из таблицы элемента, заданного каким-либо одним ключом ключем;
	- Поиск в таблице элемента по любому заданному ключу; результатом поиска должна быть копия найденного элемента со значениями всех ключей;
найденные элементы;
	- Вывод содержимого таблицы на экран; при этом формат вывода должен соответствовать приведенной выше структуре элемента таблицы;
	Если при выполнении операций с таблицами возникает ошибочная ситуация, на экран должно быть выведено соотвествующее сообщение об ошибке.
	Разработать два варианта программы:
  a) и сама таблица, и информация, относящаяся к элементу таблицы, хранятся в основной памяти;
	Примечания:
  1. Программа должна содержать несколько функций; функция main() должна выполнять: вывод меню, ввод и анализ ответа, вызов на выполнение требуемой функции;
  2. В программе нужно предусмотреть проверку правильности ввода данных;
  3. Для варианта b) следует модифицировать структуру, определяующую элемент таблицы, включив в нее длину информации и ее смещение в файле;
  4. В варианте b) для работы с файлом использовать функции пакета stdio.h; чтение и запись выполнять с помощью fread() и fwrite(), в которых должна быть указана реальная длина информации;
*/
/********************************************************************************************************************************************************************************************************/

#define _CRT_SECURE_NO_WARNINGS

#include "Header_4a.h"



// Массив диагностических сообщений об ошибках
const Type errmsgs[] = { "Ok", "Дубликат ключа (ключей) в одном из пространств", "Таблица переполнена", "Таблица пуста", "Ключ/ключи не найден/ы" };



// Альтерантивы меню для организации диалога
const Type msgs[] = { "0. Выйти", "1. Добавить", "2. Найти", "3. Удалить", "4. Вывести таблицу" };


// Кол-во альтернатив (Для вывода в for)
const int NMsgs = sizeof(msgs) / sizeof(msgs[0]);

/* Выбор номера альтернативы (Функция для выбора номера альтернативы. Возвращает правильный номер альтернативы. В строке может быть указан только номер альтернативы; если в строке
после номера альтернативы есть что-то еще, весь остаток строки удаляется из буфера) */
int dialog(const Type msgs[], int N) {
	Type errmsg = "";
	int rc, i, n;
	do {
		puts(errmsg);
		errmsg = "Ошибка! Повторите ввод:!";
		for (i = 0; i < N; ++i)       // вывод списка альтернатив
			puts(msgs[i]);
		printf("Выберите: --> ");
		n = getInt(&rc);              // Ввод номера альтернативы
		if (n == 0)                   // Конец файла - конец работы
			rc = 0;
	} while (rc < 0 || rc >= N);
	return rc;
}


int I(int k) {						        // Хеш-функция
	return k % SIZE;
}

/* Очистка потока ввода */
void clean_stdin() {
	int c;
	do
		c = getchar();    // Присваивание c символа из входного потока
	while (c != '\n' && c != EOF);
}


/* Ввод целого числа из входного потока. Если введенная строка не имеет числа(или переж них находится мусор), юзера просят ввести число еще раз. */
int getInt(int *a) {
	int n;
	do {
		n = scanf("%d", a, sizeof(int));
		if (n < 0) // Обнаружен конец файла
			return 0;
		if (n == 0) { // Обнаружен некорректный символ - ошибка
			printf("%s\n", "Ошибка! Повторите ввод:");
			clean_stdin();
		}
	} while (n == 0);
	clean_stdin();
	return 1;
}

/* Ввод строки произвольной длины из входного потока */
Type getStr() {
	char *ptr = (char *)malloc(1);
	char buf[81];
	int n, len = 0;
	*ptr = '\0';
	do {
		n = scanf("%80[^\n]", buf);
		if (n < 0) {
			free(ptr);
			ptr = NULL;
			continue;
		}
		if (n == 0)
			scanf("%*c");
		else {
			len += strlen(buf);
			ptr = (char *)realloc(ptr, len + 1);
			strcat(ptr, buf);
		}
	} while (n > 0);
	return ptr;
}



/* Диалоговая функция включения в таблицу нового элемента. Требует ввести ключ и информацию, при этом эта информация должна быть введена в новой строке, в ответ на приглашение.
Если ключ задан неправильно, вся строка игнорируется.*/
int D_Add(Table *ptab) {
	int k1, k2, rc;
	Type info = NULL;
	printf("Введите первый ключ: --> ");
	int n = getInt(&k1);
	if (n == 0)
		return 0;   // Обнаружен конец файла
	printf("Введите второй ключ: --> ");
	n = getInt(&k2);
	if (n == 0)
		return 0;   // Обнаружен конец файла
	printf("Введите информацию: --> ");
	info = getStr();
	if (info == NULL)
		return 0;  // Обнаружен конец файла
	rc = insert(ptab, k1, k2, info); // Вставка элемента в таблицу
	printf("%s: %d - %d %s\n", errmsgs[rc], k1, k2, info);
	return 1;
}

/* Ввод пространства ключей */
void input(int *k1, int* k2) {
	int n, ans;
	Type errmsg = "";
	do {
		puts(errmsg);
		errmsg = "Пространств всего два; используйте числа 1 или 2 для ответа.";
		printf("Введите кол-во ключей, по которым искать элемент: --> ");
		n = getInt(&ans);
	} while ((ans < 1) || (ans > 2));
	errmsg = "";
	if (ans == 1) {
		do {
			puts(errmsg);
			errmsg = "Пространств всего два; используйте числа 1 или 2 для ответа.";
			printf("Введите номер пространства ключа: --> ");
			n = getInt(&ans);
			if (n == 0)
				return 0;
		} while ((ans < 1) || (ans > 2));
		if (ans == 1) {
			printf("Введите ключ из первого пространства ключей: --> ");
			n = getInt(k1);
			if (n == 0)
				return 0;
			return 0;
		}
		else {
			printf("Введите ключ из второго пространства ключей: --> ");
			n = getInt(k2);
			if (n == 0)
				return 0;
			return 0;
		}
	}
	else {
		printf("Введите ключ из первого пространства ключей: --> ");
		n = getInt(k1);
		if (n == 0)
			return 0;
		printf("Введите ключ из второго пространства ключей: --> ");
		n = getInt(k2);
		if (n == 0)
			return 0;
		return 0;
	}
}


/* Диалоговая функция поиска всех элементов по ключу или конкретной версии ключа. */
int D_Find(Table *ptab) {
	int k1 = -1, k2 = -1, rc;
	input(&k1, &k2);
	rc = find(ptab, k1, k2);
	if (rc == -1) {
		printf("%s:\n", errmsgs[4]);
		return 1;
	}
	printf("\n|  Ключ 1  |  Ключ 2  |  ind 1  |  ind 2  |       Информация\n");
	printf("|%10d|%10d|%9d|%9d|   %s\n", ptab->space1[rc].key1, ptab->space1[rc].key2, ptab->space1[rc].ind1, ptab->space1[rc].ind2, ptab->space1[rc].info);
	return 1;
}


/* Диалоговая функция удаления по ключу из одного или обоих пространств */
int D_Delete(Table *ptab) {
	int k1 = -1, k2 = -1, rc;
	input(&k1, &k2);
	rc = delete(ptab, k1, k2);
	printf("%s\n", errmsgs[rc]);
	return 1;
}

/* Диалоговая функцяи вывода всей таблицы */
int D_Show(Table *ptab) {
	int rc;
	rc = output(ptab->space1);      // Вывести можно по любому пространству ключей (например, по 1-ому)
	printf("%s\n", errmsgs[rc]);
	return 1;
}


/* Табличная функция включения в таблицу нового элемента. В таблицу включается копия передаваемой информации. */
int insert(Table *ptab, int k1, int k2, Type str) {
	int strt1, i1, strt2, i2;      // Для вставки нового элемента производится предварительный поиск места; если в одной из таблиц нашелся введенный ключ - ошибка
	strt1 = i1 = I(k1);
	while (path1[i1].ind1 > 0) {
		if (path1[i1].key1 == k1)
			return 1;		     // Элемент с заданным ключом есть в таблице
		i1 = (i1 + h) % SIZE;  // Следующая позиция
		if (i1 == strt1)
			return 2;		 // Вернулись в исходную позицию - таблица полна
	}
	strt2 = i2 = I(k2);
	while (path2[i2].ind2 > 0) {
		if (path2[i2].key2 == k2)
			return 1;
		i2 = (i2 + h) % SIZE;
		if (i2 == strt2)
			return 2;
	}
	// Если элемент возможно добавить в оба пространства, то добавляем (хениально)
	add(&ptab->space1[i1], k1, k2, str, i1 + 1, i2 + 1);
	add(&ptab->space2[i2], k1, k2, str, i1 + 1, i2 + 1);
	return 0;
}

/* Добавление элемента в пространство space1/space2 на место с индексом path */
void add(Item *path, int k1, int k2, Type str, int i1, int i2) {
	path->key1 = k1;
	path->key2 = k2;
	path->info = str;
	path->ind1 = i1;
	path->ind2 = i2;
}


/* Табличная функция нахождения элементов по ключу или конкретной версии ключа. При этом создается новая таблица со всеми найденными элементами */
int find(Table *ptab, int k1, int k2) {
	int i, strt;
	if (k2 < 0) {
		strt = i = I(k1);
		do {
			if (path1[i].ind1 > 0 && path1[i].key1 == k1)
				return i;               // Возвращаем индекс элемента из первого пространства
			i = (i + h) % SIZE;
			if (i == strt)
				break;
		} while (i != strt);
	}
	if (k1 < 0) {
		strt = i = I(k2);
		do {
			if (path2[i].ind1 > 0 && path2[i].key2 == k2)
				return (path2[i].ind1 - 1);
			i = (i + h) % SIZE;
			if (i == strt)
				break;
		} while (i != strt);
	}
	else {
		strt = i = I(k1);
		do {
			if (path1[i].ind1 > 0 && path1[i].key1 == k1 && path1[i].key2 == k2)
				return i;
			i = (i + h) % SIZE;
			if (i == strt)
				break;
		} while (i != strt);
	}
	return -1;
}

/* Табличная функция удаления элемента по ключу и/или его версии. */
int delete(Table *ptab, int k1, int k2) {
	int rc = 4;
	int strt, i;
	if (k2 < 0) {
		strt = i = I(k1);
		do {
			if (path1[i].ind1 == 0)
				return 4;				// Ключ не найден
			else {
				if ((path1[i].ind1 != -1) && (path1[i].key1 == k1)) {
					path2[path1[i].ind2 - 1].ind2 = -1;
					path2[path1[i].ind2 - 1].ind2 = -1;
					path1[i].ind1 = -1;
					path1[i].ind2 = -1;
					return 0;
				}
				else
					i = (i + h) % SIZE;
			}
			if (i == strt)
				return 4;
		} while (i != strt);
	}
	if (k1 < 0) {
		strt = i = I(k2);
		do {
			if (path2[i].ind2 == 0)
				return 4;				// Ключ не найден
			else {
				if ((path2[i].ind2 != -1) && (path2[i].key2 == k2)) {
					path1[path2[i].ind1 - 1].ind1 = -1;
					path1[path2[i].ind1 - 1].ind2 = -1;
					path2[i].ind1 = -1;
					path2[i].ind2 = -1;
					return 0;
				}
				else
					i = (i + h) % SIZE;
			}
			if (i == strt)
				return 4;
		} while (i != strt);
	}
	else {
		strt = i = I(k1);
		do {
			if (path1[i].ind2 == 0)
				return 4;				// Ключ не найден
			else {
				if ((path1[i].ind1 != -1) && (path1[i].key1 == k1) && (path1[i].key2 == k2)) {
					path2[path1[i].ind1 - 1].ind1 = -1;
					path2[path1[i].ind1 - 1].ind2 = -1;
					path1[i].ind1 = -1;
					path1[i].ind2 = -1;
					return 0;
				}
				else
					i = (i + h) % SIZE;
			}
			if (i == strt)
				return 4;
		} while (i != strt);
	}
	return 1;
}


/* Табличная функция вывода таблицы (ваааще не тавтология). */
int output(Item *ptab) {
	int rc = 3;    // Изначально инициализируем таблицу как пустую
	printf("\n|  Ключ 1  |  Ключ 2  |  ind 1  |  ind 2  |       Информация\n");
	for (int i = 0; i < SIZE; ++i)
		if (ptab[i].ind1 > 0) {
			printf("|%10d|%10d|%9d|%9d|   %s\n", ptab[i].key1, ptab[i].key2, ptab[i].ind1, ptab[i].ind2, ptab[i].info);
			rc = 0;
		}
	return rc;            // Или не пустую)
}


